# 프로세스 스케줄링

## 프로세스

프로세스는 실행 중인 프로그램으로, 디스크로부터 메모리에 적재되어 CPU 의 할당을 받은 동적인 상태를 말한다.

프로그램을 실행하는 순간 컴퓨터 메모리에 파일이 올라가고 운영체제로부터 주소 공간, 파일, 메모리 등을 할당받으며 이것들을 총칭하여 프로세스라고 한다. 

## 프로세스 상태

프로세스가 실행될 때, 각 프로세스는 여러 가지 상태를 거치며 실행된다.

1. 생성 상태(New) : 프로세스가 이제 막 **메모리에 적재되어 PCB를 할당 받은 상태**.
2. 준비 상태(Ready) : CPU를 할당 받아 실행하기 위해 자신의 **차례를 기다리는 상태**.
3. 실행 상태(Running) : CPU를 할당 받아 **실행 중인 상태**.
- **일정 시간 동안**만 CPU 사용이 가능하다.
- 할당된 시간을 모두 사용하면, **타이머 인터럽트**가 발생하며 다시 준비 상태로 변경된다.
1. 대기 상태(Waiting) : 입출력 요청을 받게되어 입출력 작업을 완료할 때까지 **대기하는 상태**.
- 입출력 작업이 끝나고 **입출력 완료 인터럽트**를 받을 때까지 대기하는 상태이다.
- 정확히는 **특정 이벤트가 일어나기까지 기다리는 것**이며, 대부분의 이벤트가 입출력 작업이다.
1. 종료 상태(End) : 프로세스가 종료된 상태.

![https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png](https://user-images.githubusercontent.com/34755287/70577651-11eb7a00-1bef-11ea-9866-0c659728be9e.png)

## 프로세스 스케줄링

운영체제가 **프로세스들에게 공정하고 합리적으로 자원을 배분하는 것**을 말한다.

프로세스는 수행하면서 상태가 여러 번 변하는데 이에 따라 서비스를 받아야하는 곳이 다르다. 그리고 프로세스는 일반적으로 여러 개가 한 번에 수행되므로 그에 따른 순서가 필요하다. 이러한 순서를 대기하는 곳을 **큐(queue)**라고 부른다.

프로세스를 스케줄링하기 위한 **Queue에는 세 가지 종류가 존재**한다.

- Job Queue : 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue : 현재 메모리 내에 있으면서 CPU 를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue : I/O를 하기 위한 여러 장치를 기다리는 큐가 각각 존재한다.

[https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdeca7df3-9457-4f15-80a8-9a8fbeec9dc3%2FUntitled.png&blockId=af62e60c-83cb-4f81-a846-734b6f12fb6e](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fdeca7df3-9457-4f15-80a8-9a8fbeec9dc3%2FUntitled.png&blockId=af62e60c-83cb-4f81-a846-734b6f12fb6e)

[https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F491dacab-4a3e-4a8f-a003-1e8257a1478b%2FUntitled.png&blockId=342ad94e-f9eb-4a5a-bb1e-0d3a0d401ca3](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F491dacab-4a3e-4a8f-a003-1e8257a1478b%2FUntitled.png&blockId=342ad94e-f9eb-4a5a-bb1e-0d3a0d401ca3)

[https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d7c7c3d-8e9b-4e3d-addc-f7bc61437830%2FUntitled.png&blockId=2373a3fc-4d41-4687-890a-6db8ab574b00](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d7c7c3d-8e9b-4e3d-addc-f7bc61437830%2FUntitled.png&blockId=2373a3fc-4d41-4687-890a-6db8ab574b00)

각각의 Queue 에 프로세스들을 넣고 빼주는 스케줄러에도 크게 **세 가지 종류가** 존재한다.

- 장기 스케줄러
    - 한꺼번에 많은 프로세스들이 메모리에 올라올 경우, 메모리는 한정되어 있기 때문에 프로세스가 디스크에 임시로 저장된다.
    - 어떤 프로세스에 메모리를 할당하여 ready queue 로 보낼지 결정하는 역할을 한다.
    - **메모리와 디스크 사이의 스케줄링**을 담당.
    - **프로세스에 memory(및 각종 리소스)를 할당**(admit)
    - 프로세스의 상태 new → ready(in memory)
- 단기 스케줄러
    - Ready Queue 에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
    - **CPU 와 메모리 사이의 스케줄링**을 담당.
    - **프로세스에 CPU를 할당**(scheduler dispatch)
    - 프로세스의 상태 ready → running → waiting → ready
- 중기 스케줄러
    - 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 것을 조절하는 스케줄러.
    - 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
    - **프로세스에게서 memory 를 deallocate**
    - 프로세스의 상태 ready → suspended

Suspended(stopped) : 외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미한다. 프로세스 전부 디스크로 swap out 된다. 외부적인 이유로 수행이 정지되었기 때문에 스스로 ready state로 돌아갈 수 없다.

## 프로세스 스케줄링 알고리즘**(Process Scheduling Algorithm)**

cpu를 사용하려는 프로세스들 사이의 우선 순위를 관리하는 것을 프로세스 스케줄링이라고 한다.

운영체제가 **프로세스 스케줄링을 위해 사용하는 실질적인 방법**이다.

스케줄링은 처리율과 CPU 이용률을 증가시키고, 오버헤드/응답시간/반환시간/대기시간을 최소화 시키기 위한 기법이다. 즉, CPU가 쉬지않고 계속 열심히 일할 수 있도록 효율적인 계획을 잡아 주는 것이 스케줄링이다.

*스케줄링 대상은 Ready Queue 에 있는 프로세스들이다.*

**두 가지** 스케줄링 방식

- **비선점 스케줄링**
    - 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없다.
    - 선점 방식보다 스케줄러 호출 빈도가 낮고 문맥 교환에 의한 오버헤드도 적다.
    - 일괄처리 시스템에 적합하고, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점도 있다.
- **선점 스케줄링**
    - 하나의 프로세스가 CPU를 할당 받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있다.
    - 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있으며, 빠른 응답시간을 요하는 긴급한 프로세서를 제어할 수 있다.

### 1. 선입 선처리 스케줄링 **FCFS(First Come First Served)**

**특징**

- 준비 큐에 삽입된 순서대로 CPU를 할당해주는 방식이다.
- 비선점형(Non-Preemptive) 스케줄링
- 일단 CPU 를 잡으면 CPU burst 가 완료될 때까지 CPU 를 반환하지 않는다. 할당되었던 CPU 가 반환될 때만 스케줄링이 이루어진다.

**단점**

- 먼저 실행되는 프로세스들의 실행 시간이 길다면, 대기 중인 프로세스들이 기다리는 시간이 매우 길어질 수 있다.

### 2. 최단 작업 우선 스케줄링 **SJF(Shortest - Job - First)**

**특징**

- 실행 시간이 가장 짧은 프로세스부터 CPU를 할당해주는 방식이다.
- 비선점형(Non-Preemptive) 스케줄링

**단점**

- 이 스케줄링은 극단적으로 CPU 사용이 짧은 job 을 선호한다. 그래서 사용 시간이 긴 프로세스는 거의 영원히 CPU 를 할당받을 수 없는 기아 상태가 발생한다. **starvation**

### **3. 라운드 로빈 스케줄링 Round Robin**

**특징** 

- **준비 큐에 삽입된 순서대로 CPU를 할당**하지만, **정해진 시간(타임 슬라이스)만큼만 할당**해주는 방식이다.
- 정해진 시간동안 전부 실행되지 못했다면, 맨 마지막 순서로 돌아가서 다시 기다린다.

[https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc83c3ddd-9e94-4e68-87ff-c44c56d21d4f%2FUntitled.png&blockId=36472d76-76e7-49c4-871e-565f9bc3ac68](https://oopy.lazyrockets.com/api/v2/notion/image?src=https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc83c3ddd-9e94-4e68-87ff-c44c56d21d4f%2FUntitled.png&blockId=36472d76-76e7-49c4-871e-565f9bc3ac68)

**단점**

- 타임 슬라이스가 너무 짧을 시에는 문맥 교환 비용(Context switching)이 전체 성능에 큰 영향을 미칠 수 있다. 또한 너무 타임 슬라이스의 길이가 길어지면 곤란하다. context switching 비용을 상쇄할 수 있을 만큼 길어야한다.

### 4. 최소 잔여 시간 우선 스케줄링 **SRTF(Shortest Remaining Time First)**

**특징** 

- 선점형 (Preemptive) 스케줄링
- 현재 수행중인 프로세스의 남은 burst time 보다 더 짧은 CPU burst time 을 가지는 새로운 프로세스가 도착하면 CPU 를 뺏긴다.
- 정해진 시간만큼 CPU를 할당하되, 다음 프로세스는 남은 작업 시간이 가장 적은 프로세스를 선택하는 방식이다.

**단점**

- starvation
- 새로운 프로세스가 도달할 때마다 스케줄링을 다시하기 때문에 CPU burst time(CPU 사용시간)을 측정할 수가 없다.
- 두 번째는 프로세스의 정확한 CPU burst time을 측정할 수 없기 때문에 과거 n번째 CPU burst타임을 통해 n+1번째 burst time을 추정해야 하는데 따라서 정확한 CPU burst time을 알 수 없다.짧은 CPU burst time을 예상했지만 CPU를 훨씬 길게 점유할 수도 있게 되는 문제가 발생할 수 있다.

### 5. 우선순위 스케줄링 **Priority Scheduling**

- 프로세스들에 우선순위를 부여하고, 우선순위가 높은 프로세스부터 실행시키는 방식이다.
- 선점형 스케줄링(Preemptive) 방식더 높은 우선순위의 프로세스가 도착하면 실행중인 프로세스를 멈추고 CPU 를 선점한다.
- 비선점형 스케줄링(Non-Preemptive) 방식더 높은 우선순위의 프로세스가 도착하면 Ready Queue 의 Head 에 넣는다.

**단점**

- 우선순위가 낮은 프로세스는 무한정 실행되지 못하는 기아(Starvation)현상이 발생한다.
- 기아 현상 방지를 위해 오래 기다린 프로세스의 우선순위를 점차 높이는 에이징(Aging)기법을 사용한다.